// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Bindings for `src/libfvad/include/fvad.h`.
///
/// Regenerate bindings with `flutter pub run ffigen --config ffigen.yaml`.
///
class FvadBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  FvadBindings(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  FvadBindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// Creates and initializes a VAD instance.
  ///
  /// On success, returns a pointer to the new VAD instance, which should
  /// eventually be deleted using fvad_free().
  ///
  /// Returns NULL in case of a memory allocation error.
  ffi.Pointer<Fvad> fvad_new() {
    return _fvad_new();
  }

  late final _fvad_newPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<Fvad> Function()>>('fvad_new');
  late final _fvad_new =
      _fvad_newPtr.asFunction<ffi.Pointer<Fvad> Function()>();

  /// Frees the dynamic memory of a specified VAD instance.
  void fvad_free(
    ffi.Pointer<Fvad> inst,
  ) {
    return _fvad_free(
      inst,
    );
  }

  late final _fvad_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<Fvad>)>>(
          'fvad_free');
  late final _fvad_free =
      _fvad_freePtr.asFunction<void Function(ffi.Pointer<Fvad>)>();

  /// Reinitializes a VAD instance, clearing all state and resetting mode and
  /// sample rate to defaults.
  void fvad_reset(
    ffi.Pointer<Fvad> inst,
  ) {
    return _fvad_reset(
      inst,
    );
  }

  late final _fvad_resetPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<Fvad>)>>(
          'fvad_reset');
  late final _fvad_reset =
      _fvad_resetPtr.asFunction<void Function(ffi.Pointer<Fvad>)>();

  /// Changes the VAD operating ("aggressiveness") mode of a VAD instance.
  ///
  /// A more aggressive (higher mode) VAD is more restrictive in reporting speech.
  /// Put in other words the probability of being speech when the VAD returns 1 is
  /// increased with increasing mode. As a consequence also the missed detection
  /// rate goes up.
  ///
  /// Valid modes are 0 ("quality"), 1 ("low bitrate"), 2 ("aggressive"), and 3
  /// ("very aggressive"). The default mode is 0.
  ///
  /// Returns 0 on success, or -1 if the specified mode is invalid.
  int fvad_set_mode(
    ffi.Pointer<Fvad> inst,
    int mode,
  ) {
    return _fvad_set_mode(
      inst,
      mode,
    );
  }

  late final _fvad_set_modePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<Fvad>, ffi.Int)>>(
          'fvad_set_mode');
  late final _fvad_set_mode =
      _fvad_set_modePtr.asFunction<int Function(ffi.Pointer<Fvad>, int)>();

  /// Sets the input sample rate in Hz for a VAD instance.
  ///
  /// Valid values are 8000, 16000, 32000 and 48000. The default is 8000. Note
  /// that internally all processing will be done 8000 Hz; input data in higher
  /// sample rates will just be downsampled first.
  ///
  /// Returns 0 on success, or -1 if the passed value is invalid.
  int fvad_set_sample_rate(
    ffi.Pointer<Fvad> inst,
    int sample_rate,
  ) {
    return _fvad_set_sample_rate(
      inst,
      sample_rate,
    );
  }

  late final _fvad_set_sample_ratePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<Fvad>, ffi.Int)>>(
          'fvad_set_sample_rate');
  late final _fvad_set_sample_rate = _fvad_set_sample_ratePtr
      .asFunction<int Function(ffi.Pointer<Fvad>, int)>();

  /// Calculates a VAD decision for an audio frame.
  ///
  /// `frame` is an array of `length` signed 16-bit samples. Only frames with a
  /// length of 10, 20 or 30 ms are supported, so for example at 8 kHz, `length`
  /// must be either 80, 160 or 240.
  ///
  /// Returns              : 1 - (active voice),
  /// 0 - (non-active Voice),
  /// -1 - (invalid frame length).
  int fvad_process(
    ffi.Pointer<Fvad> inst,
    ffi.Pointer<ffi.Int16> frame,
    int length,
  ) {
    return _fvad_process(
      inst,
      frame,
      length,
    );
  }

  late final _fvad_processPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<Fvad>, ffi.Pointer<ffi.Int16>,
              ffi.Size)>>('fvad_process');
  late final _fvad_process = _fvad_processPtr.asFunction<
      int Function(ffi.Pointer<Fvad>, ffi.Pointer<ffi.Int16>, int)>();
}

final class Fvad extends ffi.Opaque {}
